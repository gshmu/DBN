<!DOCTYPE data-dictionary [
        <!ELEMENT data-dictionary (statement-execution-processor)*>
        <!ELEMENT statement-execution-processor (statement)*>
        <!ATTLIST statement-execution-processor
                id CDATA #REQUIRED
                is-query CDATA #IMPLIED
                is-prepared-statement CDATA #IMPLIED
                timeout CDATA #IMPLIED>
        <!ELEMENT statement (#PCDATA)>
        ]>
<data-dictionary>
    <statement-execution-processor id="schemas" is-query="true" is-prepared-statement="true">
        <statement>
            select
                'sqlite' as SCHEMA_NAME,
                'N' as IS_PUBLIC,
                'N' as IS_SYSTEM,
                'N' as IS_EMPTY
        </statement>
    </statement-execution-processor>
    <statement-execution-processor id="users" is-query="true" is-prepared-statement="true">
        <statement>
            select distinct
                GRANTEE as USER_NAME,
                'N' as IS_EXPIRED,
                'N' as IS_LOCKED
            from information_schema.USER_PRIVILEGES
            order by GRANTEE asc
        </statement>
    </statement-execution-processor>

    <statement-execution-processor id="tables" is-query="true" is-prepared-statement="true">
        <statement>
            select
                NAME as TABLE_NAME,
                'N' as IS_TEMPORARY
            from SQLITE_MASTER
            where
                TYPE = 'table'
            order by TABLE_NAME asc
        </statement>
    </statement-execution-processor>

    <statement-execution-processor id="views" is-query="true" is-prepared-statement="true">
        <statement>
            select
                NAME as VIEW_NAME,
                null as VIEW_TYPE_OWNER,
                null as VIEW_TYPE,
                'N' as IS_SYSTEM_VIEW
            from SQLITE_MASTER
            where
                TYPE = 'view'
            order by VIEW_NAME asc
        </statement>
    </statement-execution-processor>
    <statement-execution-processor id="dataset-names" is-query="true" is-prepared-statement="true">
        <statement>
            select
                NAME as DATASET_NAME
            from SQLITE_MASTER
            where
                TYPE = 'table' or
                TYPE = 'view'
            order by DATASET_NAME asc
        </statement>
    </statement-execution-processor>

    <statement-execution-processor id="dataset-columns" is-query="true">
        <statement>
            PRAGMA TABLE_INFO({0})
        </statement>
    </statement-execution-processor>

    <statement-execution-processor id="all-constraints" is-query="true" is-prepared-statement="true">
        <statement>
            select
                tc.TABLE_NAME as DATASET_NAME,
                case
                    when tc.CONSTRAINT_TYPE = 'PRIMARY KEY' then concat('pk_', tc.TABLE_NAME)
                    when tc.CONSTRAINT_TYPE = 'UNIQUE' then concat('unq_', tc.TABLE_NAME)
                    else tc.CONSTRAINT_NAME
                end as CONSTRAINT_NAME,
                tc.CONSTRAINT_TYPE,
                rc.UNIQUE_CONSTRAINT_SCHEMA as FK_CONSTRAINT_OWNER,
                case
                    when rc.UNIQUE_CONSTRAINT_NAME = 'PRIMARY' then concat('pk_', rc.REFERENCED_TABLE_NAME)
                    when rc.UNIQUE_CONSTRAINT_NAME = 'name' then concat('unq_', rc.REFERENCED_TABLE_NAME)
                    else rc.UNIQUE_CONSTRAINT_NAME
                end as FK_CONSTRAINT_NAME,
                'Y' as IS_ENABLED,
                null as CHECK_CONDITION
            from
                information_schema.TABLE_CONSTRAINTS tc left join
                information_schema.REFERENTIAL_CONSTRAINTS rc on
                    rc.CONSTRAINT_SCHEMA = tc.CONSTRAINT_SCHEMA and
                    rc.CONSTRAINT_NAME = tc.CONSTRAINT_NAME and
                    rc.TABLE_NAME = tc.TABLE_NAME
            where
                tc.TABLE_SCHEMA = {0}
            order by
                tc.TABLE_NAME,
                tc.CONSTRAINT_NAME asc
        </statement>
        <statement>
            select
                tc.TABLE_NAME as DATASET_NAME,
                case
                    when tc.CONSTRAINT_TYPE = 'PRIMARY KEY' then concat('pk_', tc.TABLE_NAME)
                    when tc.CONSTRAINT_TYPE = 'UNIQUE' then concat('unq_', tc.TABLE_NAME)
                    else tc.CONSTRAINT_NAME
                end as CONSTRAINT_NAME,
                tc.CONSTRAINT_TYPE,
                null as FK_CONSTRAINT_OWNER,
                null as FK_CONSTRAINT_NAME,
                'Y' as IS_ENABLED,
                null as CHECK_CONDITION
            from
                information_schema.TABLE_CONSTRAINTS tc
            where
                tc.TABLE_SCHEMA = {0}
            order by
                tc.TABLE_NAME,
                tc.CONSTRAINT_NAME asc
        </statement>
    </statement-execution-processor>

    <statement-execution-processor id="constraints" is-query="true" is-prepared-statement="true">
        <statement>

        </statement>
    </statement-execution-processor>

    <statement-execution-processor id="column-constraint-relations" is-query="true" is-prepared-statement="true">
        <statement>
        </statement>
    </statement-execution-processor>

    <statement-execution-processor id="all-column-constraint-relations" is-query="true" is-prepared-statement="true">
        <statement>
        </statement>
    </statement-execution-processor>

    <statement-execution-processor id="indexes" is-query="true" is-prepared-statement="true">
        <statement>
        </statement>
    </statement-execution-processor>

    <statement-execution-processor id="all-indexes" is-query="true" is-prepared-statement="true">
        <statement>
        </statement>
    </statement-execution-processor>

    <statement-execution-processor id="column-index-relations" is-query="true" is-prepared-statement="true">
        <statement>
        </statement>
    </statement-execution-processor>

    <statement-execution-processor id="all-column-index-relations" is-query="true" is-prepared-statement="true">
        <statement>
        </statement>
    </statement-execution-processor>

    <statement-execution-processor id="view-source-code" is-query="true" is-prepared-statement="true">
        <statement>
        </statement>
    </statement-execution-processor>    

    <statement-execution-processor id="load-distinct-values" is-query="true">
        <statement>
            select distinct {2} from {0}.{1} where {2} is not null order by {2}
        </statement>
    </statement-execution-processor>    

    <statement-execution-processor id="validate-connection" timeout="5" is-prepared-statement="true">
        <statement>
            select 1
        </statement>
    </statement-execution-processor>

</data-dictionary>
